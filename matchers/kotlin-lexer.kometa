import kometa.kotlin.Token;
import kometa.CharMatcher;

kometa KotlinLexer<Char, Token>: CharMatcher<Token> {
    override TOP = tokens;

    tokens = (token WS)* EOF -> { it.l };

    token = "#!" (~NL .)*:s -> { Token.ShebangLine(it.locus, s.s) };

    // LITERALS
    token = floatLiteral ~identifierPart -> { Token.FloatLiteral(it.locus, it.s) };
    token = doubleLiteral ~identifierPart -> { Token.DoubleLiteral(it.locus, it.s) };
    token = longLiteral ~identifierPart -> { Token.LongLiteral(it.locus, it.s) };
    token = unsignedLiteral ~identifierPart -> { Token.UnsignedLiteral(it.locus, it.s) };
    token = unsignedLongLiteral ~identifierPart -> { Token.UnsignedLongLiteral(it.locus, it.s) };
    token = integerLiteral ~identifierPart -> { Token.IntegerLiteral(it.locus, it.s) };
    token = characterLiteral -> { Token.CharacterLiteral(it.locus, it.s) };
    token = multiLineStringLiteral -> { Token.StringLiteral(it.locus, it.s) };
    token = stringLiteral -> { Token.StringLiteral(it.locus, it.s) };

    // Operators and Punctuators
    token = NL -> { Token.NewLine(it.locus) };
    token = "..." -> { Token.Reserved(it.locus) };
    token = ".." -> { Token.Range(it.locus) };
    token = "." -> { Token.Dot(it.locus) };
    token = "," -> { Token.Comma(it.locus) };
    token = "("-> { Token.LeftParen(it.locus) };
    token = ")" -> { Token.RightParen(it.locus) };
    token = "["-> { Token.LeftSquare(it.locus) };
    token = "]" -> { Token.RightSquare(it.locus) };
    token = "{" -> { Token.LeftBrace(it.locus) };
    token = "}" -> { Token.RightBrace(it.locus) };
    token = "++" -> { Token.Increment(it.locus) };
    token = "+=" -> { Token.AddAssign(it.locus) };
    token = "+" -> { Token.Add(it.locus) };
    token = "--" -> { Token.Decrement(it.locus) };
    token = "->" -> { Token.Arrow(it.locus) };
    token = "-=" -> { Token.SubAssign(it.locus) };
    token = "-" -> { Token.Sub(it.locus) };
    token = "*=" -> { Token.MulAssign(it.locus) };
    token = "*" -> { Token.Mul(it.locus) };
    token = "/=" -> { Token.DivAssign(it.locus) };
    token = "/" -> { Token.Div(it.locus) };
    token = "%=" -> { Token.ModAssign(it.locus) };
    token = "%" -> { Token.Mod(it.locus) };
    token = "&&" -> { Token.And(it.locus) };
    token = "||" -> { Token.Or(it.locus) };
    token = "!!" -> { Token.DefNotNull(it.locus) };
    token = "!==" -> { Token.NotRefEqual(it.locus) };
    token = "!=" -> { Token.NotEqual(it.locus) };
    token = "!" -> { Token.Not(it.locus) };
    token = ";" -> { Token.Semicolon(it.locus) };
    token = "::" -> { Token.CallRef(it.locus) };
    token = ":" -> { Token.Colon(it.locus) };
    token = "#" -> { Token.Hash(it.locus) };
    token = "@" -> { Token.At(it.locus) };
    token = "?::" -> { Token.SafeCallRef(it.locus) };
    token = "?:" -> { Token.Elvis(it.locus) };
    token = "?." -> { Token.SafeCall(it.locus) };
    token = "?" -> { Token.Query(it.locus) };
    token = "<=" -> { Token.LessEqual(it.locus) };
    token = "<" -> { Token.Less(it.locus) };
    token = ">=" -> { Token.GreaterEqual(it.locus) };
    token = ">" -> { Token.Greater(it.locus) };
    token = "as?" -> { Token.AsSafe(it.locus) };
    token = "===" -> { Token.RefEqual(it.locus) };
    token = "==" -> { Token.Equal(it.locus) };
    token = "=>" -> { Token.DoubleArrow(it.locus) };
    token = "=" -> { Token.Assign(it.locus) };

    // KEYWORDS
    token = "return@" identifier:name -> { Token.ReturnAt(it.locus, name.s) };
    token = "continue@" identifier:name -> { Token.ContinueAt(it.locus, name.s) };
    token = "break@" identifier:name -> { Token.BreakAt(it.locus, name.s) };
    token = "this@" identifier:name -> { Token.ThisAt(it.locus, name.s) };

    token = "file" ~identifierPart -> { Token.File(it.locus) };
    token = "package" ~identifierPart -> { Token.Package(it.locus) };
    token = "import" ~identifierPart -> { Token.Import(it.locus) };
    token = "class" ~identifierPart -> { Token.Class(it.locus) };
    token = "interface" ~identifierPart -> { Token.Interface(it.locus) };
    token = "fun" ~identifierPart -> { Token.Fun(it.locus) };
    token = "object" ~identifierPart -> { Token.Object(it.locus) };
    token = "val" ~identifierPart -> { Token.Val(it.locus) };
    token = "var" ~identifierPart -> { Token.Var(it.locus) };
    token = "typealias" ~identifierPart -> { Token.Typealias(it.locus) };
    token = "constructor" ~identifierPart -> { Token.Constructor(it.locus) };
    token = "by" ~identifierPart -> { Token.By(it.locus) };
    token = "companion" ~identifierPart -> { Token.Companion(it.locus) };
    token = "init'" ~identifierPart -> { Token.Init(it.locus) };
    token = "this" ~identifierPart -> { Token.This(it.locus) };
    token = "super" ~identifierPart -> { Token.Super(it.locus) };
    token = "typeof" ~identifierPart -> { Token.Typeof(it.locus) };
    token = "where" ~identifierPart -> { Token.Where(it.locus) };
    token = "if" ~identifierPart -> { Token.If(it.locus) };
    token = "else" ~identifierPart -> { Token.Else(it.locus) };
    token = "when" ~identifierPart -> { Token.When(it.locus) };
    token = "try" ~identifierPart -> { Token.Try(it.locus) };
    token = "catch" ~identifierPart -> { Token.Catch(it.locus) };
    token = "finally" ~identifierPart -> { Token.Finally(it.locus) };
    token = "for" ~identifierPart -> { Token.For(it.locus) };
    token = "do" ~identifierPart -> { Token.Do(it.locus) };
    token = "while" ~identifierPart -> { Token.While(it.locus) };
    token = "throw" ~identifierPart -> { Token.Throw(it.locus) };
    token = "return" ~identifierPart -> { Token.Return(it.locus) };
    token = "continue" ~identifierPart -> { Token.Continue(it.locus) };
    token = "break" ~identifierPart -> { Token.Break(it.locus) };
    token = "as" ~identifierPart -> { Token.As(it.locus) };
    token = "is" ~identifierPart -> { Token.Is(it.locus) };
    token = "in" ~identifierPart -> { Token.In(it.locus) };
    token = "!is" ~identifierPart -> { Token.NotIs(it.locus) };
    token = "!in" ~identifierPart -> { Token.NotIn(it.locus) };
    token = "out" ~identifierPart -> { Token.Out(it.locus) };
    token = "field" ~identifierPart -> { Token.Field(it.locus) };
    token = "property" ~identifierPart -> { Token.Property(it.locus) };
    token = "get" ~identifierPart -> { Token.Get(it.locus) };
    token = "set" ~identifierPart -> { Token.Set(it.locus) };
    token = "receiver" ~identifierPart -> { Token.Receiver(it.locus) };
    token = "param" ~identifierPart -> { Token.Param(it.locus) };
    token = "setparam" ~identifierPart -> { Token.Setparam(it.locus) };
    token = "delegate" ~identifierPart -> { Token.Delegate(it.locus) };
    token = "dynamic" ~identifierPart -> { Token.Dynamic(it.locus) };

    // MODIFIERS

    token = "public" ~identifierPart -> { Token.Public(it.locus) };
    token = "private" ~identifierPart -> { Token.Private(it.locus) };
    token = "protected" ~identifierPart -> { Token.Protected(it.locus) };
    token = "internal" ~identifierPart -> { Token.Internal(it.locus) };
    token = "enum" ~identifierPart -> { Token.Enum(it.locus) };
    token = "sealed" ~identifierPart -> { Token.Sealed(it.locus) };
    token = "annotation" ~identifierPart -> { Token.Annotation(it.locus) };
    token = "data" ~identifierPart -> { Token.Data(it.locus) };
    token = "inner" ~identifierPart -> { Token.Inner(it.locus) };
    token = "tailrec" ~identifierPart -> { Token.Tailrec(it.locus) };
    token = "operator" ~identifierPart -> { Token.Operator(it.locus) };
    token = "inline" ~identifierPart -> { Token.Inline(it.locus) };
    token = "infix" ~identifierPart -> { Token.Infix(it.locus) };
    token = "external" ~identifierPart -> { Token.External(it.locus) };
    token = "suspend" ~identifierPart -> { Token.Suspend(it.locus) };
    token = "override" ~identifierPart -> { Token.Override(it.locus) };
    token = "abstract" ~identifierPart -> { Token.Abstract(it.locus) };
    token = "final" ~identifierPart -> { Token.Final(it.locus) };
    token = "open" ~identifierPart -> { Token.Open(it.locus) };
    token = "const" ~identifierPart -> { Token.Const(it.locus) };
    token = "lateinit" ~identifierPart -> { Token.Lateinit(it.locus) };
    token = "vararg" ~identifierPart -> { Token.Vararg(it.locus) };
    token = "noinline" ~identifierPart -> { Token.Noinline(it.locus) };
    token = "crossinline" ~identifierPart -> { Token.Crossinline(it.locus) };
    token = "reified" ~identifierPart -> { Token.Reified(it.locus) };
    token = "true" ~identifierPart -> { Token.True(it.locus) };
    token = "false" ~identifierPart -> { Token.False(it.locus) };
    token = "null" ~identifierPart -> { Token.Null(it.locus) };
    token = "value" ~identifierPart -> { Token.Value(it.locus) };
    token = "expect" ~identifierPart -> { Token.Expect(it.locus) };
    token = "actual" ~identifierPart -> { Token.Actual(it.locus) };

    // Identifier
    token = identifier -> { Token.Identifier(it.locus, it.s) };

    floatLiteral = (doubleLiteral | decLiteral) ('f' | 'F');
    doubleLiteral = doubleLiteralStart doubleLiteralPart;

    doubleLiteralStart = (decDigitNoZero (decDigit | '_')* decDigit)? '.';
    doubleLiteralStart = ((decDigitNoZero decDigit*) | '0')? '.';

    doubleLiteralPart = decDigit (decDigit | '_')+ decDigit ('e' | 'E') ('+' | '-')? decDigit (decDigit | '_')+ decDigit;
    doubleLiteralPart = decDigit (decDigit | '_')+ decDigit ('e' | 'E') ('+' | '-')? decDigit+;
    doubleLiteralPart = decDigit+ ('e' | 'E') ('+' | '-')? decDigit (decDigit | '_')+ decDigit;
    doubleLiteralPart = decDigit+ ('e' | 'E') ('+' | '-')? decDigit+;
    doubleLiteralPart = decDigit (decDigit | '_')+ decDigit;
    doubleLiteralPart = decDigit+;

    longLiteral = integerLiteral ('l' | 'L');
    unsignedLiteral = integerLiteral ('l' | 'L');
    unsignedLongLiteral = integerLiteral ("ul" | "UL");
    integerLiteral = decLiteral | hexLiteral | binLiteral;

    decLiteral = '0';
    decLiteral = decDigitNoZero (decDigit | '_')+ decDigit ('e' | 'E') ('+' | '-')? decDigit (decDigit | '_')+ decDigit;
    decLiteral = decDigitNoZero (decDigit | '_')+ decDigit ('e' | 'E') ('+' | '-')? decDigit+;
    decLiteral = decDigitNoZero decDigit* ('e' | 'E') ('+' | '-')? decDigit (decDigit | '_')+ decDigit;
    decLiteral = decDigitNoZero decDigit* ('e' | 'E') ('+' | '-')? decDigit+;
    decLiteral = decDigitNoZero (decDigit | '_')+ decDigit;
    decLiteral = decDigitNoZero decDigit*;

    decDigit = '0' | decDigitNoZero;
    decDigitNoZero = ['1'-'9'];

    hexLiteral = '0' ('x' | 'X') hexDigit (hexDigit | '_')*;

    hexDigit = decDigit | ['a'-'h'] | ['A'-'H'];

    binLiteral = '0' ('b' | 'B') binDigit (binDigit | '_')*;

    binDigit = '0' | '1';

    characterLiteral = '\'' (escapeSeq | '.') '\'';

    escapeSeq = '\\' ('t' | 'b' | 'r' | 'n' | '\'' | '"' | '\\' | '$') | uniEscapeChar;

    uniEscapeChar = "\\u" hexDigit hexDigit hexDigit hexDigit;

    multiLineStringLiteral = "\"\"\"" (stringExpression | strRef | multiLineStrText | multiLineStringQuote)* ("\"\"\"" | !"unclosed string literal");

    stringExpression = '$' &'{' kotlinCode;

    strRef = '$' identifier;

    multiLineStrText = ~('\\' | '"' | '$') . | '$';

    multiLineStringQuote = "\"\"" | '"';

    stringLiteral = '"' (stringExpression | strRef | strEscapedChar | strText)* '"';

    strText = ~('\\' | '"' | '$') . | '$';

    strEscapedChar = '\\' . | uniEscapeChar;

    kotlinCode = '{' (~'}' (NL | comment | kotlinCode | .))* '}';
    kotlinCode = '(' (~')' (NL | comment | kotlinCode | .))* ')';
    kotlinCode = '\u0027' (NL | "\u005c\u0027" | "\u005c\u005c" | ~'\u0027' .)* '\u0027';   // '
    kotlinCode = '\u0022' (NL | "\u005c\u0022" | "\u005c\u005c" | ~'\u0022' .)* '\u0022';   // "

    identifier = identifierStart identifierPart*;

    identifierStart = . ?(it.i.isJavaIdentifierStart());

    identifierPart = . ?(it.i.isJavaIdentifierPart());

    WS = ('\u0020' | '\u0009' | '\u000C' | comment)*;

    comment = lineComment | delimetedComment;

    lineComment = "//" (~NL .)*;

    delimetedComment = "/*" (delimetedComment | .)* "*/";

    NL = '\n' | ('\r' '\n');

    EOF = ~.;
}